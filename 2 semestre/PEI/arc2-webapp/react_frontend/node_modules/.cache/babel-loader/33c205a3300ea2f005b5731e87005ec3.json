{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/home/couto/Desktop/Universidade/PEI/arc2-webapp/react_frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;\nws = require('ws');\nutil = require('util');\nevents = require('events');\nMpeg1Muxer = require('./mpeg1muxer');\nSTREAM_MAGIC_BYTES = \"jsmp\"; // Must be 4 bytes\n\nVideoStream = function VideoStream(options) {\n  this.options = options;\n  this.name = options.name;\n  this.streamUrl = options.streamUrl;\n  this.width = options.width;\n  this.height = options.height;\n  this.wsPort = options.wsPort;\n  this.inputStreamStarted = false;\n  this.stream = undefined;\n  this.startMpeg1Stream();\n  this.pipeStreamToSocketServer();\n  return this;\n};\n\nutil.inherits(VideoStream, events.EventEmitter);\n\nVideoStream.prototype.stop = function () {\n  this.wsServer.close();\n  this.stream.kill();\n  this.inputStreamStarted = false;\n  return this;\n};\n\nVideoStream.prototype.startMpeg1Stream = function () {\n  var gettingInputData, gettingOutputData, inputData, outputData;\n  this.mpeg1Muxer = new Mpeg1Muxer({\n    ffmpegOptions: this.options.ffmpegOptions,\n    url: this.streamUrl,\n    ffmpegPath: this.options.ffmpegPath == undefined ? \"ffmpeg\" : this.options.ffmpegPath\n  });\n  this.stream = this.mpeg1Muxer.stream;\n\n  if (this.inputStreamStarted) {\n    return;\n  }\n\n  this.mpeg1Muxer.on('mpeg1data', data => {\n    return this.emit('camdata', data);\n  });\n  gettingInputData = false;\n  inputData = [];\n  gettingOutputData = false;\n  outputData = [];\n  this.mpeg1Muxer.on('ffmpegStderr', data => {\n    var size;\n    data = data.toString();\n\n    if (data.indexOf('Input #') !== -1) {\n      gettingInputData = true;\n    }\n\n    if (data.indexOf('Output #') !== -1) {\n      gettingInputData = false;\n      gettingOutputData = true;\n    }\n\n    if (data.indexOf('frame') === 0) {\n      gettingOutputData = false;\n    }\n\n    if (gettingInputData) {\n      inputData.push(data.toString());\n      size = data.match(/\\d+x\\d+/);\n\n      if (size != null) {\n        size = size[0].split('x');\n\n        if (this.width == null) {\n          this.width = parseInt(size[0], 10);\n        }\n\n        if (this.height == null) {\n          return this.height = parseInt(size[1], 10);\n        }\n      }\n    }\n  });\n  this.mpeg1Muxer.on('ffmpegStderr', function (data) {\n    return global.process.stderr.write(data);\n  });\n  this.mpeg1Muxer.on('exitWithError', () => {\n    return this.emit('exitWithError');\n  });\n  return this;\n};\n\nVideoStream.prototype.pipeStreamToSocketServer = function () {\n  this.wsServer = new ws.Server({\n    port: this.wsPort\n  });\n  this.wsServer.on(\"connection\", (socket, request) => {\n    return this.onSocketConnect(socket, request);\n  });\n\n  this.wsServer.broadcast = function (data, opts) {\n    var results;\n    results = [];\n\n    var _iterator = _createForOfIteratorHelper(this.clients),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        let client = _step.value;\n\n        if (client.readyState === 1) {\n          results.push(client.send(data, opts));\n        } else {\n          results.push(console.log(\"Error: Client from remoteAddress \" + client.remoteAddress + \" not connected.\"));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return results;\n  };\n\n  return this.on('camdata', data => {\n    return this.wsServer.broadcast(data);\n  });\n};\n\nVideoStream.prototype.onSocketConnect = function (socket, request) {\n  var streamHeader; // Send magic bytes and video size to the newly connected socket\n  // struct { char magic[4]; unsigned short width, height;}\n\n  streamHeader = new Buffer(8);\n  streamHeader.write(STREAM_MAGIC_BYTES);\n  streamHeader.writeUInt16BE(this.width, 4);\n  streamHeader.writeUInt16BE(this.height, 6);\n  socket.send(streamHeader, {\n    binary: true\n  });\n  console.log(\"\".concat(this.name, \": New WebSocket Connection (\") + this.wsServer.clients.size + \" total)\");\n  socket.remoteAddress = request.connection.remoteAddress;\n  return socket.on(\"close\", (code, message) => {\n    return console.log(\"\".concat(this.name, \": Disconnected WebSocket (\") + this.wsServer.clients.size + \" total)\");\n  });\n};\n\nmodule.exports = VideoStream;","map":{"version":3,"sources":["/home/couto/Desktop/Universidade/PEI/arc2-webapp/react_frontend/node_modules/node-rtsp-stream/videoStream.js"],"names":["Mpeg1Muxer","STREAM_MAGIC_BYTES","VideoStream","events","util","ws","require","options","name","streamUrl","width","height","wsPort","inputStreamStarted","stream","undefined","startMpeg1Stream","pipeStreamToSocketServer","inherits","EventEmitter","prototype","stop","wsServer","close","kill","gettingInputData","gettingOutputData","inputData","outputData","mpeg1Muxer","ffmpegOptions","url","ffmpegPath","on","data","emit","size","toString","indexOf","push","match","split","parseInt","global","process","stderr","write","Server","port","socket","request","onSocketConnect","broadcast","opts","results","clients","client","readyState","send","console","log","remoteAddress","streamHeader","Buffer","writeUInt16BE","binary","connection","code","message","module","exports"],"mappings":"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","sourcesContent":["var Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws\n\nws = require('ws')\n\nutil = require('util')\n\nevents = require('events')\n\nMpeg1Muxer = require('./mpeg1muxer')\n\nSTREAM_MAGIC_BYTES = \"jsmp\" // Must be 4 bytes\n\nVideoStream = function(options) {\n  this.options = options\n  this.name = options.name\n  this.streamUrl = options.streamUrl\n  this.width = options.width\n  this.height = options.height\n  this.wsPort = options.wsPort\n  this.inputStreamStarted = false\n  this.stream = undefined\n  this.startMpeg1Stream()\n  this.pipeStreamToSocketServer()\n  return this\n}\n\nutil.inherits(VideoStream, events.EventEmitter)\n\nVideoStream.prototype.stop = function() {\n  this.wsServer.close()\n  this.stream.kill()\n  this.inputStreamStarted = false\n  return this\n}\n\nVideoStream.prototype.startMpeg1Stream = function() {\n  var gettingInputData, gettingOutputData, inputData, outputData\n  this.mpeg1Muxer = new Mpeg1Muxer({\n    ffmpegOptions: this.options.ffmpegOptions,\n    url: this.streamUrl,\n    ffmpegPath: this.options.ffmpegPath == undefined ? \"ffmpeg\" : this.options.ffmpegPath\n  })\n  this.stream = this.mpeg1Muxer.stream\n  if (this.inputStreamStarted) {\n    return\n  }\n  this.mpeg1Muxer.on('mpeg1data', (data) => {\n    return this.emit('camdata', data)\n  })\n  gettingInputData = false\n  inputData = []\n  gettingOutputData = false\n  outputData = []\n  this.mpeg1Muxer.on('ffmpegStderr', (data) => {\n    var size\n    data = data.toString()\n    if (data.indexOf('Input #') !== -1) {\n      gettingInputData = true\n    }\n    if (data.indexOf('Output #') !== -1) {\n      gettingInputData = false\n      gettingOutputData = true\n    }\n    if (data.indexOf('frame') === 0) {\n      gettingOutputData = false\n    }\n    if (gettingInputData) {\n      inputData.push(data.toString())\n      size = data.match(/\\d+x\\d+/)\n      if (size != null) {\n        size = size[0].split('x')\n        if (this.width == null) {\n          this.width = parseInt(size[0], 10)\n        }\n        if (this.height == null) {\n          return this.height = parseInt(size[1], 10)\n        }\n      }\n    }\n  })\n  this.mpeg1Muxer.on('ffmpegStderr', function(data) {\n    return global.process.stderr.write(data)\n  })\n  this.mpeg1Muxer.on('exitWithError', () => {\n    return this.emit('exitWithError')\n  })\n  return this\n}\n\nVideoStream.prototype.pipeStreamToSocketServer = function() {\n  this.wsServer = new ws.Server({\n    port: this.wsPort\n  })\n  this.wsServer.on(\"connection\", (socket, request) => {\n    return this.onSocketConnect(socket, request)\n  })\n  this.wsServer.broadcast = function(data, opts) {\n    var results\n    results = []\n    for (let client of this.clients) {\n      if (client.readyState === 1) {\n        results.push(client.send(data, opts))\n      } else {\n        results.push(console.log(\"Error: Client from remoteAddress \" + client.remoteAddress + \" not connected.\"))\n      }\n    }\n    return results\n  }\n  return this.on('camdata', (data) => {\n    return this.wsServer.broadcast(data)\n  })\n}\n\nVideoStream.prototype.onSocketConnect = function(socket, request) {\n  var streamHeader\n  // Send magic bytes and video size to the newly connected socket\n  // struct { char magic[4]; unsigned short width, height;}\n  streamHeader = new Buffer(8)\n  streamHeader.write(STREAM_MAGIC_BYTES)\n  streamHeader.writeUInt16BE(this.width, 4)\n  streamHeader.writeUInt16BE(this.height, 6)\n  socket.send(streamHeader, {\n    binary: true\n  })\n  console.log(`${this.name}: New WebSocket Connection (` + this.wsServer.clients.size + \" total)\")\n\n  socket.remoteAddress = request.connection.remoteAddress\n\n  return socket.on(\"close\", (code, message) => {\n    return console.log(`${this.name}: Disconnected WebSocket (` + this.wsServer.clients.size + \" total)\")\n  })\n}\n\nmodule.exports = VideoStream"]},"metadata":{},"sourceType":"script"}